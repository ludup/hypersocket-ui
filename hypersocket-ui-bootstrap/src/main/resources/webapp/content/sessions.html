<style>
    #chartdiv {
        width: 100%;
        height: 500px;
        margin-bottom: 20px;
        background-color: lavender; 
        font-family: -apple-system,BlinkMacSystemFont,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;
    }
</style>

<div id="contentSessions">
</div>
<!-- HTML -->
<div id="chartdiv"></div>
<script type="text/javascript">

var HeatMap = class HeatMap {
	
	    constructor(data) {
	
	        HeatMap.continents = {
	            "AF": 0,
	            "AN": 1,
	            "AS": 2,
	            "EU": 3,
	            "NA": 4,
	            "OC": 5,
	            "SA": 6
	        }
	
	        this.data = data;
	        this.chart = undefined
	        this.worldSeries = undefined
	        this.countrySeries = undefined
	        this.imageSeries = undefined
	        this.mapDataContext = undefined
	        this.init();
	        this.initWorldMapSeries();
	        this.initCountryMapSeries();
	        this.registerZoomControl();
	        this.registerHomeButtonControl();
	
	    }
	
	    init() {
	
	        this.chart = am4core.create("chartdiv", am4maps.MapChart);
	        this.chart.projection = new am4maps.projections.Miller();
	
	        // Create map polygon series for world map
	        this.worldSeries = this.chart.series.push(new am4maps.MapPolygonSeries());
	        this.worldSeries.useGeodata = true;
	        this.worldSeries.geodata = am4geodata_worldLow;
	        this.worldSeries.exclude = ["AQ"];
	
	        this.worldSeries.events.on("validated", () => {
	            if (this.imageSeries) {
	                this.imageSeries.invalidate();
	            }
	        })
	
	        let worldPolygon = this.worldSeries.mapPolygons.template;
	        worldPolygon.tooltipText = "{name}";
	        worldPolygon.nonScalingStroke = true;
	        worldPolygon.strokeOpacity = 0.5;
	        worldPolygon.fill = am4core.color("#eee");
	        worldPolygon.propertyFields.fill = "color";
	
	        let hs = worldPolygon.states.create("hover");
	        hs.properties.fill = this.chart.colors.getIndex(9);
	
	        // Set up click events
	        worldPolygon.events.on("hit", (ev) => {
	            ev.target.series.chart.zoomToMapObject(ev.target);
	            this.mapDataContext = ev.target.dataItem.dataContext
	            let map = this.mapDataContext.map;
	            if (map) {
	                ev.target.isHover = false;
	                this.loadCountryMap(map);
	            }
	        });
	
	        this.registerNewImageSeries(this.data["world"], this.worldSeries);
	    }
	
	    registerHomeButtonControl() {
	        this.homeButton = new am4core.Button();
	        this.homeButton.events.on("hit", () => {
	            this.clearImageSeries();
	            this.registerNewImageSeries(this.data["world"], this.worldSeries);
	            this.worldSeries.show();
	            this.countrySeries.hide();
	            this.chart.goHome();
	        });
	
	        this.homeButton.icon = new am4core.Sprite();
	        this.homeButton.padding(7, 5, 7, 5);
	        this.homeButton.width = 30;
	        this.homeButton.icon.path = "M16,8 L14,8 L14,16 L10,16 L10,10 L6,10 L6,16 L2,16 L2,8 L0,8 L8,0 L16,8 Z M16,8";
	        this.homeButton.marginBottom = 10;
	        this.homeButton.parent = this.chart.zoomControl;
	        this.homeButton.insertBefore(this.chart.zoomControl.plusButton);
	    }
	
	    clearImageSeries() {
	        if (this.imageSeries) {
	            this.imageSeries.tooltip.hide();
	            this.imageSeries.dispose();
	            this.chart.series.removeValue(this.imageSeries);
	        }
	    }
	
	    registerNewImageSeries(data, mapSeries) {
	        this.imageSeries = this.chart.series.push(new am4maps.MapImageSeries());
	        this.imageSeries.addData(data);
	        this.imageSeries.toFront()
	        this.imageSeries.dataFields.value = "value";
	
	        this.addImageIndicator(this.imageSeries, mapSeries);
	    }
	
	    initWorldMapSeries() {
	        // Set up data for countries
	        let data = [];
	        for(let id in am4geodata_data_countries2) {
	            if (am4geodata_data_countries2.hasOwnProperty(id)) {
	                let country = am4geodata_data_countries2[id];
	                if (country.maps.length) {
	                    data.push({
	                        id: id,
	                        color: this.chart.colors.getIndex(HeatMap.continents[country.continent_code]),
	                        map: country.maps[0]
	                    });
	                }
	            }
	        }
	        this.worldSeries.data = data;
	    }
	
	    initCountryMapSeries() {
	        // Create country specific series (but hide it for now)
	        this.countrySeries = this.chart.series.push(new am4maps.MapPolygonSeries());
	        this.countrySeries.useGeodata = true;
	        this.countrySeries.hide();
	        this.countrySeries.geodataSource.events.on("done", (ev) => {
	            this.worldSeries.hide();
	            this.countrySeries.show();
	
	            let stateMap = {};
				var features = ev.data.features;
				for (let i = 0; i < features.length; ++i) {
					stateMap[features[i].properties.id] = features[i].properties.name;
				}
	            if (this.mapDataContext) {
	
	                let name = this.mapDataContext.name;
	                getJSON("session/geoInfoByRegion/" + this.mapDataContext.id, null, (response) =>  {
	                	if (response.success) {
	                		var resource = response.resource;
	                		var regionData = [];
	                		for (k in resource) {
	                			regionData.push({ "id": k, "name": stateMap[k], "value": resource[k]});
							}
	                		
	                		this.registerNewImageSeries(regionData, this.countrySeries);
	                	}
	                });
	            } else {
	                this.registerNewImageSeries([], this.countrySeries);
	            }
	
	            
	        });
	
	        let countryPolygon = this.countrySeries.mapPolygons.template;
	        countryPolygon.tooltipText = "{name}";
	        countryPolygon.nonScalingStroke = true;
	        countryPolygon.strokeOpacity = 0.5;
	        countryPolygon.fill = am4core.color("#eee");
	
	        let hs = countryPolygon.states.create("hover");
	        hs.properties.fill = this.chart.colors.getIndex(9);
	
	    }
	
	    registerZoomControl() {
	        // Zoom control
	        this.chart.zoomControl = new am4maps.ZoomControl();
	    }
	
	    addImageIndicator(imageSeries, mapSeries) {
	        let imageTemplate = imageSeries.mapImages.template;
	        imageTemplate.nonScaling = true
	
	        imageTemplate.adapter.add("latitude", function (latitude, target) {
	            let polygon = mapSeries.getPolygonById(target.dataItem.dataContext.id);
	            if (polygon) {
	                return polygon.visualLatitude;
	            }
	            return latitude;
	        })
	
	        imageTemplate.adapter.add("longitude", function (longitude, target) {
	            let polygon = mapSeries.getPolygonById(target.dataItem.dataContext.id);
	            if (polygon) {
	                return polygon.visualLongitude;
	            }
	            return longitude;
	        })
	
	        let circle = imageTemplate.createChild(am4core.Circle);
	        circle.fillOpacity = 0.7;
	        circle.fill = "#1e0c51";
	        circle.tooltipText = "{name}: [bold]{value}[/]";
	
	        circle.events.on("hit", (ev) => {
	            let countryId = ev.target.parent.dataItem.dataContext.id;
	            let country = am4geodata_data_countries2[countryId];
	
	            let polygon = this.worldSeries.getPolygonById(countryId);
	            if (polygon) {
	                this.chart.zoomToMapObject(polygon);
	            }
	
	            if (country) {
	                let map = country.maps[0];
	                if (map) {
	                    this.mapDataContext = { name : country.country, id: countryId }
	                    // we need set timeout else map will go for a toss
	                    // it needs next tick cycle, internal to amcharts
	                    setTimeout(() => this.loadCountryMap(map), 0);
	                }
	            }
	        })
	
	        imageSeries.heatRules.push({
	            "target": circle,
	            "property": "radius",
	            "min": 4,
	            "max": 15,
	            "dataField": "value"
	        })
	
	        let label = imageTemplate.createChild(am4core.Label);
	        label.text = "{name}"
	        label.horizontalCenter = "middle";
	        label.padding(0, 0, 0, 0);
	        label.adapter.add("dy", function (dy, target) {
	            let circle = target.parent.children.getIndex(0);
	            return circle.pixelRadius;
	        })
	    }
	
	    loadCountryMap(map) {
	        this.clearImageSeries();
	        this.countrySeries.geodataSource.url = "${uiPath}/js/amcharts/maps/json/" + map + ".json";
	        this.countrySeries.geodataSource.load();
	    }
	}
	
	function loadScript(url, complete) {
		var script = jQuery( "<script>" )
		.attr( {} )
		.prop( {  src: url } )
		.on( "load error", callback = function( evt ) {
			script.remove();
			callback = null;
			if ( evt ) {
				complete( evt.type === "error" ? 404 : 200, evt.type );
			}
		} );

		document.head.appendChild( script[ 0 ] );
	}

	function formatTime(ms) {
		if(ms < 60000) 
			return parseInt( ms / 1000 ) + 's';
		else if(ms < 120000) 
			return '1m ' + parseInt( ( ms - 60000 ) / 1000 ) + 's';
		else if(ms < 3600000) 
			return parseInt( ms / 60000 ) + 'm';
		else if(ms < 7200000) 
			return '1h ' + parseInt( ( ms - 3600000) / 60000 ) + 'm';
		else 
			return parseInt( ms / 3600000 ) + 'h';
	}

	legacyjQueryReadyFix(function() {
		$('#contentSessions').ajaxResourcePage(
				{
					id : "Session",
					tableUrl : "session/table",
					title: getResource("sessions.label"),
					icon: 'fa-hourglass-start',
					resourceUrl: 'session/logoff',
					disableEditView: true,
					fields : [ {
						name : "principalName",
						formatter: function(value, obj, index) {
							if(obj.session.currentPrincipal) {
				        	   return cleanValue(obj.session.currentPrincipal.name);
							} else {
								return "";
							}
				           }
						},
						 {
							name : "session.remoteAddress"
						 },
						 {
							 name: "session.createDate",
							 formatter: function(value, obj, index) {
								 return new Date(value).format("mmm dd HH:MM");
							 }
						 },
						 {
							 name: "session.lastUpdated",
							 formatter: function(value, obj, index) {
								 return new Date(value).format("mmm dd HH:MM");
							 }
						 },
						 {
							 name: "session.connectedFor",
							 formatter: function(value, row, index) {
								 return formatTime(row.session.totalSeconds * 1000);
							 }
						 },
						 {
							 name: "session.os"
						 },
						 {
							 name: "session.userAgent"
						 },
						 {
							 name: "stateMap",
							 formatter: function(value, obj, index) {
								 if (value["location_country_code"] && value["location_region_code"]) {
									 return value["location_country_code"] + "-" + value["location_region_code"]
								 } else if (value["location_country_code"]) {
									 return value["location_country_code"]
								 }
								 
								 return undefined;
								 
							 }
						 }
						],
					resourceKey : "session",
					sortName: 'createDate',
					sortOrder: 'desc',
					canCreate: false,
					canUpdate: false,
					canDelete: currentMenu.canDelete,
					checkDelete: function(session) {
						return $(document).data('session').id != session.id;
					},
					complete : function() {
						loadScript("${uiPath}/js/amcharts/maps/maps.js", (data) => {
							loadScript("${uiPath}/js/amcharts/dark.js", (data) => {
								loadScript("${uiPath}/js/amcharts/maps/worldLow.js", (data) => {
									loadScript("${uiPath}/js/amcharts/maps/data/countries2.js", (data) => {
										 am4core.ready(function() {
											 getJSON("session/geoInfoByCountry", null, (response) =>  {
												 if (response.success) {
													 	let mapData = [];
														let resource = response.resource;
														for (k in resource) {
															mapData.push({ "id": k, "name": am4geodata_data_countries2[k].country, "value": resource[k]});
														}
														let hm = new HeatMap({"world" : mapData});
												        loadComplete();
											 	}	
										        
										    });
										});
									});
								});
							});
						});
					}
		});
	});
</script>




